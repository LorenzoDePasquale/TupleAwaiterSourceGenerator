using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TupleAwaiterSourceGenerator;

[Generator]
public class TupleAwaiterSourceGenerator : IIncrementalGenerator
{
    enum TaskType { Task, ValueTask }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var expressions = context.SyntaxProvider
                                 .CreateSyntaxProvider((node, _) => IsTupleAwaitExpression(node), (ctx, _) => AnalyzeExpression(ctx))
                                 .Where(taskTypes => taskTypes.Any())
                                 .Collect();
        context.RegisterSourceOutput(expressions, GenerateExtensionMethods);
    }

    static bool IsTupleAwaitExpression(SyntaxNode node) => node is AwaitExpressionSyntax { Expression: TupleExpressionSyntax };

    static TaskType[] AnalyzeExpression(GeneratorSyntaxContext context)
    {
        if (context.Node is not AwaitExpressionSyntax { Expression: TupleExpressionSyntax tupleExpression})
        {
            return [];
        }

        TypeInfo[] tupleItemsType = tupleExpression.Arguments.Select(arg => context.SemanticModel.GetTypeInfo(arg.Expression)).ToArray();

        if (tupleItemsType.Length <= 1)
        {
            // Not a multi-item tuple
            return [];
        }

        if (tupleItemsType.Any(typeInfo => typeInfo.Type is not INamedTypeSymbol { Name: "Task" or "ValueTask", TypeArguments.Length: 1 }))
        {
            // The tuple contains items that are not a Task<T> or ValueTask<T>
            return [];
        }

        return tupleItemsType.Select(typeInfo => typeInfo.Type!.Name switch
        {
            "Task" => TaskType.Task,
            "ValueTask" => TaskType.ValueTask,
            _ => throw new ArgumentOutOfRangeException() // This will never be thrown, it's here to make the compiler happy
        }).ToArray();
    }

    static void GenerateExtensionMethods(SourceProductionContext context, ImmutableArray<TaskType[]> tuples)
    {
        if (tuples.IsEmpty)
        {
            return;
        }

        HashSet<string> methodsParams = [];
        StringBuilder sb = new();
        // lang=c#
        sb.AppendLine("""
                      // <auto-generated/>

                      using System;
                      using System.Runtime.CompilerServices;
                      using System.Threading.Tasks;

                      public static class TupleAwaiterExtensions
                      {
                      """);

        foreach (TaskType[] taskTypes in tuples)
        {
            string taskTypeParams = string.Join(", ", taskTypes.Select((taskType, i) => $"{taskType}<T{i + 1}>"));

            if (!methodsParams.Contains(taskTypeParams))
            {
                sb.AppendLine(GenerateExtensionMethod(taskTypes));
                sb.AppendLine();
                methodsParams.Add(taskTypeParams);
            }
        }

        sb.AppendLine("}");
        context.AddSource("ExtensionMethods.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

        HashSet<int> tupleItemsCount = [];
        sb.Clear();
        // lang=c#
        sb.AppendLine("""
                      // <auto-generated/>

                      using System;
                      using System.Runtime.CompilerServices;
                      using System.Threading.Tasks;
                      
                      """);

        foreach (TaskType[] taskTypes in tuples)
        {
            if (!tupleItemsCount.Contains(taskTypes.Length))
            {
                sb.AppendLine(GenerateAwaiter(taskTypes));
                sb.AppendLine();
                tupleItemsCount.Add(taskTypes.Length);
            }
        }

        context.AddSource("TupleAwaiters.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    static string GenerateExtensionMethod(TaskType[] taskTypes)
    {
        string returnType = $"Task{taskTypes.Length}Awaiter";
        string typeParams = string.Join(", ", taskTypes.Select((_, i) => $"T{i + 1}"));
        string taskTypeParams = string.Join(", ", taskTypes.Select((taskType, i) => $"{taskType}<T{i + 1}>"));
        string taskArray = string.Join(", ", taskTypes.Select((taskType, i) => taskType == TaskType.Task ? $"tasks.Item{i + 1}" : $"tasks.Item{i + 1}.AsTask()"));

        // lang=c#
        return $$"""
            public static {{returnType}}<{{typeParams}}> GetAwaiter<{{typeParams}}>(this ({{taskTypeParams}}) tasks)
            {
                return new {{returnType}}<{{typeParams}}>({{taskArray}});
            }
        """;
    }

    static string GenerateAwaiter(TaskType[] taskTypes)
    {
        IEnumerable<int> indices = Enumerable.Range(1, taskTypes.Length).ToArray();
        string structName = $"Task{taskTypes.Length}Awaiter";
        string typeParams = string.Join(", ", indices.Select(i => $"T{i}"));
        string parameters = string.Join(", ", indices.Select(i => $"Task<T{i}> task{i}"));
        string privateFields = string.Join("\n    ", indices.Select(i => $"Task<T{i}> _task{i};"));
        string fieldAssignments = string.Join("\n        ", indices.Select(i => $"_task{i} = task{i};"));
        string whenAllTaskCall = $"{string.Join(", ", indices.Select(i => $"task{i}"))}";
        string resultTuple = string.Join(", ", indices.Select(i => $"_task{i}.Result"));

        // lang=c#
        return $$"""
        public struct {{structName}}<{{typeParams}}> : INotifyCompletion
        {
            {{privateFields}}
            Task _whenAllTask;
        
            public {{structName}}({{parameters}})
            {
                {{fieldAssignments}}
                _whenAllTask = Task.WhenAll({{whenAllTaskCall}});
            }
        
            public bool IsCompleted => _whenAllTask.IsCompleted;
        
            public void OnCompleted(Action continuation)
            {
                _whenAllTask.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);
            }
        
            public ({{typeParams}}) GetResult()
            {
                _whenAllTask.GetAwaiter().GetResult();
                return ({{resultTuple}});
            }
        }
        """;
    }
}
