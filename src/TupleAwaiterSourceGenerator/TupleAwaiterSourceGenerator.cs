using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TupleAwaiterSourceGenerator;

[Generator]
public class TupleAwaiterSourceGenerator : IIncrementalGenerator
{
    enum TaskType { Task, ValueTask }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var expressions = context.SyntaxProvider
                                 .CreateSyntaxProvider((node, _) => IsAwaitTuple(node) || IsAwaitTupleWithConfigureAwait(node), (ctx, _) => AnalyzeExpression(ctx))
                                 .Where(taskTypes => taskTypes.Any())
                                 .Collect();

        context.RegisterSourceOutput(expressions, GenerateExtensionMethods);
    }

    static bool IsAwaitTuple(SyntaxNode node)
    {
        // Matches nodes like await (task1, task2)
        return node is AwaitExpressionSyntax { Expression: TupleExpressionSyntax };
    }

    static bool IsAwaitTupleWithConfigureAwait(SyntaxNode node)
    {
        // Matches nodes like await (task1, task2).ConfigureAwait(false)
        return node is AwaitExpressionSyntax
        {
            Expression: InvocationExpressionSyntax
            {
                Expression: MemberAccessExpressionSyntax
                {
                    Name: IdentifierNameSyntax { Identifier.Text: "ConfigureAwait" },
                    Expression: TupleExpressionSyntax
                }
            }
        };
    }

    static TaskType[] AnalyzeExpression(GeneratorSyntaxContext context)
    {
        var tupleExpression = ((AwaitExpressionSyntax)context.Node).Expression switch
        {
            TupleExpressionSyntax expression => expression,
            InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax { Expression: TupleExpressionSyntax expression } } => expression,
            _ => throw new ArgumentException() // This will never be thrown, it's here to make the compiler happy
        };

        TypeInfo[] tupleItemsTypes = tupleExpression.Arguments.Select(arg => context.SemanticModel.GetTypeInfo(arg.Expression)).ToArray();

        return GetTaskTypes(tupleItemsTypes);
    }

    static TaskType[] GetTaskTypes(TypeInfo[] tupleItemsType)
    {
        if (tupleItemsType.Length <= 1)
        {
            // Not a multi-item tuple
            return [];
        }

        if (tupleItemsType.Any(typeInfo => !IsGenericTaskOrValueTask(typeInfo)))
        {
            // The tuple contains items that are not a Task<T> or ValueTask<T>
            return [];
        }

        return tupleItemsType.Select(typeInfo => typeInfo.Type!.Name switch
        {
            "Task" => TaskType.Task,
            "ValueTask" => TaskType.ValueTask,
            _ => throw new ArgumentException() // This will never be thrown, it's here to make the compiler happy
        }).ToArray();
    }

    static bool IsGenericTaskOrValueTask(TypeInfo typeInfo) => typeInfo.Type is INamedTypeSymbol { Name: "Task" or "ValueTask", TypeArguments.Length: 1 };

    static void GenerateExtensionMethods(SourceProductionContext context, ImmutableArray<TaskType[]> tuples)
    {
        if (tuples.IsEmpty)
        {
            return;
        }

        HashSet<string> methodsParams = [];
        StringBuilder sb = new();
        // lang=c#
        sb.AppendLine("""
                      // <auto-generated/>

                      using System;
                      using System.Runtime.CompilerServices;
                      using System.Threading.Tasks;

                      public static class TupleAwaiterExtensions
                      {
                      """);

        foreach (TaskType[] taskTypes in tuples)
        {
            string taskTypeParams = string.Join(", ", taskTypes.Select((taskType, i) => $"{taskType}<T{i + 1}>"));

            if (!methodsParams.Contains(taskTypeParams))
            {
                sb.AppendLine(GenerateExtensionMethod(taskTypes));
                sb.AppendLine();
                methodsParams.Add(taskTypeParams);
            }
        }

        sb.AppendLine("}");
        context.AddSource("ExtensionMethods.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

        HashSet<int> tupleItemsCount = [];
        sb.Clear();
        // lang=c#
        sb.AppendLine("""
                      // <auto-generated/>

                      using System;
                      using System.Runtime.CompilerServices;
                      using System.Threading.Tasks;
                      
                      """);

        foreach (TaskType[] taskTypes in tuples)
        {
            if (!tupleItemsCount.Contains(taskTypes.Length))
            {
                sb.AppendLine(GenerateAwaiter(taskTypes));
                sb.AppendLine();
                tupleItemsCount.Add(taskTypes.Length);
            }
        }

        context.AddSource("TupleAwaiters.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    static string GenerateExtensionMethod(TaskType[] taskTypes)
    {
        string typeParams = string.Join(", ", taskTypes.Select((_, i) => $"T{i + 1}"));
        string taskTypeParams = string.Join(", ", taskTypes.Select((taskType, i) => $"{taskType}<T{i + 1}>"));
        string taskArray = string.Join(", ", taskTypes.Select((taskType, i) => taskType == TaskType.Task ? $"tasks.Item{i + 1}" : $"tasks.Item{i + 1}.AsTask()"));

        // lang=c#
        return $$"""
            public static TupleTaskAwaiter<{{typeParams}}> GetAwaiter<{{typeParams}}>(this ({{taskTypeParams}}) tasks)
            {
                return new TupleTaskAwaiter<{{typeParams}}>({{taskArray}}, ConfigureAwaitOptions.ContinueOnCapturedContext);
            }

            public static TupleConfiguredTaskAwaitable<{{typeParams}}> ConfigureAwait<{{typeParams}}>(this ({{taskTypeParams}}) tasks, bool continueOnCapturedContext)
            {
                return new TupleConfiguredTaskAwaitable<{{typeParams}}>({{taskArray}}, continueOnCapturedContext ? ConfigureAwaitOptions.ContinueOnCapturedContext : ConfigureAwaitOptions.None);
            }

            public static TupleConfiguredTaskAwaitable<{{typeParams}}> ConfigureAwait<{{typeParams}}>(this ({{taskTypeParams}}) tasks, ConfigureAwaitOptions options)
            {
                return new TupleConfiguredTaskAwaitable<{{typeParams}}>({{taskArray}}, options);
            }
        """;
    }

    static string GenerateAwaiter(TaskType[] taskTypes)
    {
        IEnumerable<int> indices = Enumerable.Range(1, taskTypes.Length).ToArray();
        string typeParams = string.Join(", ", indices.Select(i => $"T{i}"));
        string parameters = string.Join(", ", indices.Select(i => $"Task<T{i}> task{i}"));
        string privateFields = $"readonly {string.Join("\n    readonly ", indices.Select(i => $"Task<T{i}> _task{i};"))}";
        string fieldAssignments = string.Join("\n        ", indices.Select(i => $"_task{i} = task{i};"));
        string whenAllArguments = $"{string.Join(", ", indices.Select(i => $"task{i}"))}";
        string newAwaiterArguments = $"{string.Join(", ", indices.Select(i => $"_task{i}"))}";
        string resultTuple = string.Join(", ", indices.Select(i => $"_task{i}.Result"));

        // lang=c#
        return $$"""
        public readonly struct TupleTaskAwaiter<{{typeParams}}> : INotifyCompletion
        {
            {{privateFields}}
            readonly ConfiguredTaskAwaitable.ConfiguredTaskAwaiter _whenAllAwaiter;

            internal TupleTaskAwaiter({{parameters}}, ConfigureAwaitOptions options)
            {
                {{fieldAssignments}}
                _whenAllAwaiter = Task.WhenAll({{whenAllArguments}}).ConfigureAwait(options).GetAwaiter();
            }

            public bool IsCompleted => _whenAllAwaiter.IsCompleted;

            public void OnCompleted(Action continuation) => _whenAllAwaiter.OnCompleted(continuation);

            public ({{typeParams}}) GetResult()
            {
                _whenAllAwaiter.GetResult();
                return ({{resultTuple}});
            }
        }

        public readonly struct TupleConfiguredTaskAwaitable<{{typeParams}}>
        {
            {{privateFields}}
            readonly ConfigureAwaitOptions _options;

            internal TupleConfiguredTaskAwaitable({{parameters}}, ConfigureAwaitOptions options)
            {
                {{fieldAssignments}}
                _options = options;
            }

            public TupleTaskAwaiter<{{typeParams}}> GetAwaiter() => new({{newAwaiterArguments}}, _options);
        }
        """;
    }
}
